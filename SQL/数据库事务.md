### 一、数据库的事务：

事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是不可分割的一个序列。

 **原子性（Atomicity）** 、 **一致性（Consistency）** 、 **隔离性（Isolation）** 、 **持久性（Durability）** 

#### 特征：

1. 原子性：事务的操作要么全做要么不做。
2. 一致性：事务操作的结果是一个一致状态转换到另一个一致状态。
3. 隔离性：一个事务的执行过程不能受到其他事务的干扰。
4. 持久性：事务一旦提交，对数据库做出的更新将是永久的。

------

### 二、并发控制：

#### 并发操作带来的问题：

1. 丢失修改：修改的数据被覆盖不可重复读。
2. 数据被修改或者插入删除，结果不能复现。
3. 读脏数据:脏数据是未提交的数据。

------

可串行化调度： 如果多个事务的并发执行和某一串行执行顺序结果相同，则称为可串行化调度。 冲突可串行化调度： 冲突操作：不同事务的读写操作和写写操作。 不同事务的冲突操作和同一事务的两个操作都不能交换执行顺序。

并发控制的技术： 1、时间戳： 给每个事务分配一个全局的唯一的时间戳，唯一性且单调增长性。时间戳可以为系统时钟值，也可以为逻辑计数器，同一事务中的数据操作有相同的时间戳。此方法需要大量的系统资源。 2、乐观控制法： 假设不会发生冲突。读阶段——确认阶段——写阶段。 3、锁： 排它锁（X锁）：写锁，一个事务获取了写锁，则其他事务都不能再加任何类型的锁，直到锁释放。 共享锁（S锁）：读锁，一个事务获取了读锁，其他事务能加读锁，不能加写锁。

```
（1） 锁协议：
 1、一级封锁协议：事务在修改数据前先加写锁，直到事务结束。（防止修改）
 2、二级封锁协议：在一级的基础上，事务读数据先加读锁，读完释放读锁。（防止读脏）
 3、三级封锁协议：在一级的基础上，事务读数据先加读锁，直到事务结束释放。（防止不可重复读）
（2）两端封锁协议：事务执行过程中，不允许加锁释放锁交叉执行。
 1、申请封锁期
 2、释放封锁期
（3）InnoDB行锁算法：
 行记录锁：
 间隙锁：锁定一个范围。
 next-key lock: 锁定一个范围，并锁定记录。
```

锁带来的问题： 1、活锁： 某一事务一直在等待锁。采用先来先服务的策略。 2、死锁： 事务互相等待锁。 预防：一次将所有需要的数据全部加锁；规定一个封锁顺序 诊断死锁并解除：超时法；等待图法，如果有环则有死锁。解除死锁：选择回滚代价最小的事务；回滚多远；避免饿死。

锁的粒度越大，能够封锁的单元就越少，其并发度越低，系统开销越小。一个系统支持多个封锁粒度供不同的事务选择，叫多粒度封锁。 多粒度锁协议：对一个结点加锁意味着这个节点的所有后裔节点都被加同样的锁。显示封锁：直接加到数据对象的锁，隐式封锁：该数据对象是由于上级节点加锁而加上的锁。 意向锁：对任意节点加锁，就必须先对它的上层节点加意向锁。意向共享锁，意向排他所，共享意向排他锁。

![1614670358792](C:\Users\km\AppData\Roaming\Typora\typora-user-images\1614670358792.png)

