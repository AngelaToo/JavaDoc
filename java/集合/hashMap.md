一、基础知识

key-vaule

存储-》put

```
*第一步**首先将k,v封装到Node对象当中（节点）。
*第二步**它的底层会调用K的hashCode()方法得出hash值。
*第三步**通过哈希表函数/哈希算法，将hash值转换成数组的下标，下标位置上如果没有任何元素，就把Node添加到这个位置上。如果说下标对应的位置上有链表。此时，就会拿着k和链表上每个节点的k进行equal。如果所有的equals方法返回都是false，那么这个新的节点将被添加到链表的末尾。如其中有一个equals返回了true，那么这个节点的value将会被覆盖 
```

查询-》get

```
 第一步：先调用k的hashCode()方法得出哈希值，并通过哈希算法转换成数组的下标。
 第二步：通过上一步哈希算法转换成数组的下标之后，在通过数组下标快速定位到某个位置上。重点理解如果这个位置上什么都没有，则返回null。如果这个位置上有单向链表，那么它就会拿着参数K和单向链表上的每一个节点的K进行equals，如果所有equals方法都返回false，则get方法返回null。如果其中一个节点的K和参数K进行equals返回true，那么此时该节点的value就是我们要找的value了，get方法最终返回这个要找的value。 
```

二、技术本质

算法：哈希算法、哈希冲突

jdk1.7  数组+链表

jdk1.8之后 数组+链表+红黑数

解决链表过长查询效率过低的问题

阈值：8

为什么是8？

红黑树插入的数据效率低